#ifndef PHYSICSDOM_IMPL_H
#define PHYSICSDOM_IMPL_H

// CreateDOM: Schema Generation tool written by John W. Ratcliff, 2017
// Warning:This source file was auto-generated by the CreateDOM tool. Do not try to edit this source file manually!
// The Google DOCs Schema Spreadsheet for this source came from: https://docs.google.com/spreadsheets/d/118I5kdu2XT-6wfCG044937xfEKDyX2oNg04G8Wqi6o0/edit?usp=sharing

#include "PhysicsDOM.h"
#include <string>
#include <vector>
#include <stdint.h>


namespace PHYSICS_DOM
{


// Forward declare the two types of string vector containers.
typedef std::vector< std::string > StringVector;
typedef std::vector< const char * > ConstCharVector;

// Declare the clone-object class for deep copies
// of objects by the implementation classes
// Not to be used with the base DOM classes;
// they do not support deep copies
// Also declares the virtual method to init the DOM contents.
class CloneObject
{
public:
	// Declare the default virtual clone method; not implemented for DOM objects; only used for the implementation versions.
	virtual CloneObject *clone(void) const { return nullptr; };
	// Declare the default initDOM method; which is only needed for some implementation objects.
	virtual void initDOM(void) {  };
};

// Defines an optional visual mesh binding to a physics node
class VisualBindingDef: public CloneObject
{
public:

	// Declare the constructor.
	VisualBindingDef() { }


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	VisualBindingDef(const VisualBindingDef &other)
	{
		*this = other;
	}


	virtual VisualBinding * getVisualBinding(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new VisualBindingDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	VisualBindingDef& operator=(const VisualBindingDef& other)
	{
		if (this != &other )
		{
			mVisualName = other.mVisualName;
			mLocalPose = other.mLocalPose;
			mLocalScale = other.mLocalScale;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		mDOM.visualName = mVisualName.c_str(); // Assign the current string pointer.
		mDOM.localPose = mLocalPose; // Simple member variable assignment to the DOM reflection: localPose
		mDOM.localScale = mLocalScale; // Simple member variable assignment to the DOM reflection: localScale
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	VisualBindingDef(VisualBindingDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	VisualBindingDef& operator=(VisualBindingDef&& other)
	{
		if (this != &other )
		{
			mVisualName = other.mVisualName;
			mLocalPose = other.mLocalPose;
			mLocalScale = other.mLocalScale;
		}
		return *this;
	}

	std::string	mVisualName; 									// Name of associated visual mesh
	Pose 		mLocalPose;   										// Local relative pose of visual mesh to corresponding physics node
	Vec3 		mLocalScale;											// Local relative scale of visual mesh to corresponding physics node
private:
	VisualBinding  mDOM; // Declare the DOM version.
};


// Describes a key-value pair for custom properties on a node
class KeyValuePairDef: public CloneObject
{
public:

	// Declare the constructor.
	KeyValuePairDef() { }


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	KeyValuePairDef(const KeyValuePairDef &other)
	{
		*this = other;
	}


	virtual KeyValuePair * getKeyValuePair(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new KeyValuePairDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	KeyValuePairDef& operator=(const KeyValuePairDef& other)
	{
		if (this != &other )
		{
			mKey = other.mKey;
			mValue = other.mValue;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		mDOM.key = mKey.c_str(); // Assign the current string pointer.
		mDOM.value = mValue.c_str(); // Assign the current string pointer.
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	KeyValuePairDef(KeyValuePairDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	KeyValuePairDef& operator=(KeyValuePairDef&& other)
	{
		if (this != &other )
		{
			mKey = other.mKey;
			mValue = other.mValue;
		}
		return *this;
	}

	std::string	mKey;  											// They 'key' identifier; what this property is
	std::string	mValue;											// The value of this property; up to each the user to figure out how to interpret each property relative to the keyword
private:
	KeyValuePair mDOM; // Declare the DOM version.
};

typedef std::vector< KeyValuePairDef > KeyValuePairVectorDef; // Forward declare the 'KeyValuePair' vector
typedef std::vector< KeyValuePair > KeyValuePairVectorDOM; // Forward declare the 'KeyValuePair' vector

// A collection of key/value pair properties relative to a particular category
class AdditionalPropertiesDef: public CloneObject
{
public:

	// Declare the constructor.
	AdditionalPropertiesDef() { }


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	AdditionalPropertiesDef(const AdditionalPropertiesDef &other)
	{
		*this = other;
	}


	virtual AdditionalProperties * getAdditionalProperties(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new AdditionalPropertiesDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	AdditionalPropertiesDef& operator=(const AdditionalPropertiesDef& other)
	{
		if (this != &other )
		{
			mCategory = other.mCategory;
			mKeyValuePairs = other.mKeyValuePairs;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		mDOM.category = mCategory.c_str(); // Assign the current string pointer.
		mKeyValuePairsDOM.clear();
		mKeyValuePairsDOM.reserve( mKeyValuePairs.size() );
		for (auto &i:mKeyValuePairs)
		{
			i.initDOM();
			mKeyValuePairsDOM.push_back( *(i.getKeyValuePair()) );
		}
		mDOM.keyValuePairsCount = uint32_t(mKeyValuePairsDOM.size()); // assign the number of items in the array.
		mDOM.keyValuePairs = mDOM.keyValuePairsCount ? &mKeyValuePairsDOM[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	AdditionalPropertiesDef(AdditionalPropertiesDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	AdditionalPropertiesDef& operator=(AdditionalPropertiesDef&& other)
	{
		if (this != &other )
		{
			mCategory = other.mCategory;
			mKeyValuePairs = other.mKeyValuePairs;
		}
		return *this;
	}

	std::string	mCategory;   									// The category this set of key/value pairs is associated with (example 'physx', 'mujoco', etc.
	KeyValuePairVectorDef mKeyValuePairs;  						// The array of key/value pairs associated with this category
private:
	AdditionalProperties mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
	KeyValuePairVectorDOM mKeyValuePairsDOM; // Scratch array for const char pointers.
};

typedef std::vector< AdditionalPropertiesDef > AdditionalPropertiesVectorDef; // Forward declare the 'AdditionalProperties' vector
typedef std::vector< AdditionalProperties > AdditionalPropertiesVectorDOM; // Forward declare the 'AdditionalProperties' vector

// Base class that specifies a unique ID and an optional description name field for an object
class NodeDef: public CloneObject
{
public:

	// Declare the constructor.
	NodeDef() { }


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	NodeDef(const NodeDef &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new NodeDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	NodeDef& operator=(const NodeDef& other)
	{
		if (this != &other )
		{
			mId = other.mId;
			mName = other.mName;
			mType = other.mType;
			mVisual = other.mVisual;
			mAdditionalProperties = other.mAdditionalProperties;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		mDOM.id = mId.c_str(); // Assign the current string pointer.
		mDOM.name = mName.c_str(); // Assign the current string pointer.
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		{
			VisualBindingDef *impl = static_cast< VisualBindingDef *>(&mVisual); // static cast to the implementation class.
			impl->initDOM(); // Initialize DOM components of member variable.
			mDOM.visual = *impl->getVisualBinding(); // Copy the DOM struct values.
		}
		mAdditionalPropertiesDOM.clear();
		mAdditionalPropertiesDOM.reserve( mAdditionalProperties.size() );
		for (auto &i:mAdditionalProperties)
		{
			i.initDOM();
			mAdditionalPropertiesDOM.push_back( *(i.getAdditionalProperties()) );
		}
		mDOM.additionalPropertiesCount = uint32_t(mAdditionalPropertiesDOM.size()); // assign the number of items in the array.
		mDOM.additionalProperties = mDOM.additionalPropertiesCount ? &mAdditionalPropertiesDOM[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	NodeDef(NodeDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	NodeDef& operator=(NodeDef&& other)
	{
		if (this != &other )
		{
			mId = other.mId;
			mName = other.mName;
			mType = other.mType;
			mVisual = other.mVisual;
			mAdditionalProperties = other.mAdditionalProperties;
		}
		return *this;
	}

	std::string	mId; 											// Unique Id for this object
	std::string	mName;   										// Optional name for this object
	NodeType 	mType{ NT_NODE };									// The type of node
	VisualBindingDef mVisual;  									// Optional visual bindings for this node; for exaple some physics components have a corresponding named graphics component
	AdditionalPropertiesVectorDef mAdditionalProperties; 		// An optional set of properties for this node; a set of key-value pairs for each application/engine specific category
private:
	Node 		mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
	AdditionalPropertiesVectorDOM mAdditionalPropertiesDOM; // Scratch array for const char pointers.
};


// Defines the physical material properties of a surface
class PhysicsMaterialDef : public NodeDef
{
public:
	// Declare the constructor.
	PhysicsMaterialDef()
	{
		NodeDef::mType = NT_PHYSICS_MATERIAL;
	}


	// Declare the virtual destructor.
	virtual ~PhysicsMaterialDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	PhysicsMaterialDef(const PhysicsMaterialDef &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual PhysicsMaterial * getPhysicsMaterial(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new PhysicsMaterialDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	PhysicsMaterialDef& operator=(const PhysicsMaterialDef& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(other);
			mDisableFriction = other.mDisableFriction;
			mDisableStrongFriction = other.mDisableStrongFriction;
			mDynamicFriction = other.mDynamicFriction;
			mStaticFriction = other.mStaticFriction;
			mRestitution = other.mRestitution;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeDef::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.disableFriction = mDisableFriction; // Simple member variable assignment to the DOM reflection: disableFriction
		mDOM.disableStrongFriction = mDisableStrongFriction; // Simple member variable assignment to the DOM reflection: disableStrongFriction
		mDOM.dynamicFriction = mDynamicFriction; // Simple member variable assignment to the DOM reflection: dynamicFriction
		mDOM.staticFriction = mStaticFriction; // Simple member variable assignment to the DOM reflection: staticFriction
		mDOM.restitution = mRestitution; // Simple member variable assignment to the DOM reflection: restitution
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	PhysicsMaterialDef(PhysicsMaterialDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	PhysicsMaterialDef& operator=(PhysicsMaterialDef&& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(std::move(other));
			mDisableFriction = other.mDisableFriction;
			mDisableStrongFriction = other.mDisableStrongFriction;
			mDynamicFriction = other.mDynamicFriction;
			mStaticFriction = other.mStaticFriction;
			mRestitution = other.mRestitution;
		}
		return *this;
	}

	bool 		mDisableFriction{ false };  							// If true, then friction is disabled for the material
	bool 		mDisableStrongFriction{ false };						// If true then strong friction is disabled for the material
	float  		mDynamicFriction{ 0.5f };   						// The coefficient of dynamic friction.
	float  		mStaticFriction{ 0.5f };  							// The coefficient of static friction
	float  		mRestitution{ 0.5f };   							// The coefficient of resitution.
private:
	PhysicsMaterial mDOM; // Declare the DOM version.
};

typedef std::vector< Vec3 > Vec3VectorDef; // Forward declare the 'Vec3' vector

// Describes the data for a convex hull
class ConvexHullDef : public NodeDef
{
public:
	// Declare the constructor.
	ConvexHullDef()
	{
		NodeDef::mType = NT_CONVEXHULL;
	}


	// Declare the virtual destructor.
	virtual ~ConvexHullDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	ConvexHullDef(const ConvexHullDef &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual ConvexHull * getConvexHull(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new ConvexHullDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	ConvexHullDef& operator=(const ConvexHullDef& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(other);
			mPoints = other.mPoints;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeDef::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.pointsCount = uint32_t(mPoints.size()); // assign the number of items in the array.
		mDOM.points = mDOM.pointsCount ? &mPoints[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	ConvexHullDef(ConvexHullDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	ConvexHullDef& operator=(ConvexHullDef&& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(std::move(other));
			mPoints = other.mPoints;
		}
		return *this;
	}

	Vec3VectorDef  mPoints;										// Array of data points describing the convex hull
private:
	ConvexHull   mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
};

typedef std::vector< uint32_t > U32VectorDef; // Forward declare the 'U32' vector
typedef std::vector< uint8_t > U8VectorDef; // Forward declare the 'U8' vector

// Describes the data for a triangle mesh
class TriangleMeshDef : public NodeDef
{
public:
	// Declare the constructor.
	TriangleMeshDef()
	{
		NodeDef::mType = NT_TRIANGLEMESH;
	}


	// Declare the virtual destructor.
	virtual ~TriangleMeshDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	TriangleMeshDef(const TriangleMeshDef &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual TriangleMesh * getTriangleMesh(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new TriangleMeshDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	TriangleMeshDef& operator=(const TriangleMeshDef& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(other);
			mPoints = other.mPoints;
			mTriangles = other.mTriangles;
			mMaterialIndices = other.mMaterialIndices;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeDef::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.pointsCount = uint32_t(mPoints.size()); // assign the number of items in the array.
		mDOM.points = mDOM.pointsCount ? &mPoints[0] : nullptr; // Assign the pointer array
		mDOM.trianglesCount = uint32_t(mTriangles.size()); // assign the number of items in the array.
		mDOM.triangles = mDOM.trianglesCount ? &mTriangles[0] : nullptr; // Assign the pointer array
		mDOM.materialIndicesCount = uint32_t(mMaterialIndices.size()); // assign the number of items in the array.
		mDOM.materialIndices = mDOM.materialIndicesCount ? &mMaterialIndices[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	TriangleMeshDef(TriangleMeshDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	TriangleMeshDef& operator=(TriangleMeshDef&& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(std::move(other));
			mPoints = other.mPoints;
			mTriangles = other.mTriangles;
			mMaterialIndices = other.mMaterialIndices;
		}
		return *this;
	}

	Vec3VectorDef  mPoints;										// Array of vertices for the triangle mesh
	U32VectorDef mTriangles; 									// Array of triangle indices
	U8VectorDef	mMaterialIndices;  								// Optional per-triangle material index
private:
	TriangleMesh mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
};

typedef std::vector< uint16_t > U16VectorDef; // Forward declare the 'U16' vector

// The data for a heighfield; as 2d array of 32 bit samples; 16 bits for height, 16 bits for material indices, holes, and other metadata
class HeightFieldDef : public NodeDef
{
public:
	// Declare the constructor.
	HeightFieldDef()
	{
		NodeDef::mType = NT_HEIGHTFIELD;
	}


	// Declare the virtual destructor.
	virtual ~HeightFieldDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	HeightFieldDef(const HeightFieldDef &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual HeightField * getHeightField(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new HeightFieldDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	HeightFieldDef& operator=(const HeightFieldDef& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(other);
			mRowCount = other.mRowCount;
			mColumnCount = other.mColumnCount;
			mSamples = other.mSamples;
			mMetaData = other.mMetaData;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeDef::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.rowCount = mRowCount; // Simple member variable assignment to the DOM reflection: rowCount
		mDOM.columnCount = mColumnCount; // Simple member variable assignment to the DOM reflection: columnCount
		mDOM.samplesCount = uint32_t(mSamples.size()); // assign the number of items in the array.
		mDOM.samples = mDOM.samplesCount ? &mSamples[0] : nullptr; // Assign the pointer array
		mDOM.metaDataCount = uint32_t(mMetaData.size()); // assign the number of items in the array.
		mDOM.metaData = mDOM.metaDataCount ? &mMetaData[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	HeightFieldDef(HeightFieldDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	HeightFieldDef& operator=(HeightFieldDef&& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(std::move(other));
			mRowCount = other.mRowCount;
			mColumnCount = other.mColumnCount;
			mSamples = other.mSamples;
			mMetaData = other.mMetaData;
		}
		return *this;
	}

	uint32_t 	mRowCount{ 0 };  									// Number of sample rows in the height field samples array.
	uint32_t 	mColumnCount{ 0 }; 								// Number of sample columns in the height field samples array.
	U16VectorDef mSamples;   									// Heightfield sample data
	U16VectorDef mMetaData;										// Optional meta data for each sample; determines per sample material, winding order, and whether or not to treat it as a hole
private:
	HeightField	mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
};


// Base class for all geometries
class GeometryDef: public CloneObject
{
public:

	// Declare the constructor.
	GeometryDef() { }


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	GeometryDef(const GeometryDef &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new GeometryDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	GeometryDef& operator=(const GeometryDef& other)
	{
		if (this != &other )
		{
			mType = other.mType;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	GeometryDef(GeometryDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	GeometryDef& operator=(GeometryDef&& other)
	{
		if (this != &other )
		{
			mType = other.mType;
		}
		return *this;
	}

	GeometryType mType;											// 
private:
	Geometry 	mDOM; // Declare the DOM version.
};


// Defines a box geometry
class BoxGeometryDef : public GeometryDef
{
public:
	// Declare the constructor.
	BoxGeometryDef()
	{
		GeometryDef::mType = GT_BOX_GEOMETRY;
	}


	// Declare the virtual destructor.
	virtual ~BoxGeometryDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	BoxGeometryDef(const BoxGeometryDef &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual BoxGeometry * getBoxGeometry(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new BoxGeometryDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	BoxGeometryDef& operator=(const BoxGeometryDef& other)
	{
		if (this != &other )
		{
			GeometryDef::operator=(other);
			mDimensions = other.mDimensions;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		GeometryDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Geometry *dom = static_cast< Geometry *>(&mDOM); // Get the DOM base class.
			*dom = *(GeometryDef::getGeometry()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.dimensions = mDimensions; // Simple member variable assignment to the DOM reflection: dimensions
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	BoxGeometryDef(BoxGeometryDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	BoxGeometryDef& operator=(BoxGeometryDef&& other)
	{
		if (this != &other )
		{
			GeometryDef::operator=(std::move(other));
			mDimensions = other.mDimensions;
		}
		return *this;
	}

	Vec3 		mDimensions{ 1,1,1 }; 								// Dimensions of the box
private:
	BoxGeometry	mDOM; // Declare the DOM version.
};


// Defines a sphere geometry
class SphereGeometryDef : public GeometryDef
{
public:
	// Declare the constructor.
	SphereGeometryDef()
	{
		GeometryDef::mType = GT_SPHERE_GEOMETRY;
	}


	// Declare the virtual destructor.
	virtual ~SphereGeometryDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	SphereGeometryDef(const SphereGeometryDef &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual SphereGeometry * getSphereGeometry(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new SphereGeometryDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	SphereGeometryDef& operator=(const SphereGeometryDef& other)
	{
		if (this != &other )
		{
			GeometryDef::operator=(other);
			mRadius = other.mRadius;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		GeometryDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Geometry *dom = static_cast< Geometry *>(&mDOM); // Get the DOM base class.
			*dom = *(GeometryDef::getGeometry()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.radius = mRadius; // Simple member variable assignment to the DOM reflection: radius
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	SphereGeometryDef(SphereGeometryDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	SphereGeometryDef& operator=(SphereGeometryDef&& other)
	{
		if (this != &other )
		{
			GeometryDef::operator=(std::move(other));
			mRadius = other.mRadius;
		}
		return *this;
	}

	float  		mRadius{ 1 };   									// The radius of the sphere
private:
	SphereGeometry   mDOM; // Declare the DOM version.
};


// Defines a capsule geometry
class CapsuleGeometryDef : public GeometryDef
{
public:
	// Declare the constructor.
	CapsuleGeometryDef()
	{
		GeometryDef::mType = GT_CAPSULE_GEOMETRY;
	}


	// Declare the virtual destructor.
	virtual ~CapsuleGeometryDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	CapsuleGeometryDef(const CapsuleGeometryDef &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual CapsuleGeometry * getCapsuleGeometry(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new CapsuleGeometryDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	CapsuleGeometryDef& operator=(const CapsuleGeometryDef& other)
	{
		if (this != &other )
		{
			GeometryDef::operator=(other);
			mRadius = other.mRadius;
			mHeight = other.mHeight;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		GeometryDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Geometry *dom = static_cast< Geometry *>(&mDOM); // Get the DOM base class.
			*dom = *(GeometryDef::getGeometry()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.radius = mRadius; // Simple member variable assignment to the DOM reflection: radius
		mDOM.height = mHeight; // Simple member variable assignment to the DOM reflection: height
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	CapsuleGeometryDef(CapsuleGeometryDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	CapsuleGeometryDef& operator=(CapsuleGeometryDef&& other)
	{
		if (this != &other )
		{
			GeometryDef::operator=(std::move(other));
			mRadius = other.mRadius;
			mHeight = other.mHeight;
		}
		return *this;
	}

	float  		mRadius{ 1 };   									// The radius of the capsule
	float  		mHeight{ 1 };   									// The height of the capsule
private:
	CapsuleGeometry mDOM; // Declare the DOM version.
};


// Defines a cylinder geometry
class CylinderGeometryDef : public GeometryDef
{
public:
	// Declare the constructor.
	CylinderGeometryDef()
	{
		GeometryDef::mType = GT_CYLINDER_GEOMETRY;
	}


	// Declare the virtual destructor.
	virtual ~CylinderGeometryDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	CylinderGeometryDef(const CylinderGeometryDef &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual CylinderGeometry * getCylinderGeometry(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new CylinderGeometryDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	CylinderGeometryDef& operator=(const CylinderGeometryDef& other)
	{
		if (this != &other )
		{
			GeometryDef::operator=(other);
			mRadius = other.mRadius;
			mHeight = other.mHeight;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		GeometryDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Geometry *dom = static_cast< Geometry *>(&mDOM); // Get the DOM base class.
			*dom = *(GeometryDef::getGeometry()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.radius = mRadius; // Simple member variable assignment to the DOM reflection: radius
		mDOM.height = mHeight; // Simple member variable assignment to the DOM reflection: height
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	CylinderGeometryDef(CylinderGeometryDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	CylinderGeometryDef& operator=(CylinderGeometryDef&& other)
	{
		if (this != &other )
		{
			GeometryDef::operator=(std::move(other));
			mRadius = other.mRadius;
			mHeight = other.mHeight;
		}
		return *this;
	}

	float  		mRadius{ 1 };   									// The radius of the cylinder
	float  		mHeight{ 1 };   									// The height of the cylinder
private:
	CylinderGeometry mDOM; // Declare the DOM version.
};


// Defines a convex mesh geometry
class ConvexHullGeometryDef : public GeometryDef
{
public:
	// Declare the constructor.
	ConvexHullGeometryDef()
	{
		GeometryDef::mType = GT_CONVEXHULL_GEOMETRY;
	}


	// Declare the virtual destructor.
	virtual ~ConvexHullGeometryDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	ConvexHullGeometryDef(const ConvexHullGeometryDef &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual ConvexHullGeometry * getConvexHullGeometry(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new ConvexHullGeometryDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	ConvexHullGeometryDef& operator=(const ConvexHullGeometryDef& other)
	{
		if (this != &other )
		{
			GeometryDef::operator=(other);
			mScale = other.mScale;
			mConvexMesh = other.mConvexMesh;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		GeometryDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Geometry *dom = static_cast< Geometry *>(&mDOM); // Get the DOM base class.
			*dom = *(GeometryDef::getGeometry()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.scale = mScale; // Simple member variable assignment to the DOM reflection: scale
		mDOM.convexMesh = mConvexMesh.c_str(); // Assign the current string pointer.
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	ConvexHullGeometryDef(ConvexHullGeometryDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	ConvexHullGeometryDef& operator=(ConvexHullGeometryDef&& other)
	{
		if (this != &other )
		{
			GeometryDef::operator=(std::move(other));
			mScale = other.mScale;
			mConvexMesh = other.mConvexMesh;
		}
		return *this;
	}

	MeshScale  	mScale;											// The scale to apply to this convex mesh
	std::string	mConvexMesh; 									// The name of the convex mesh asset
private:
	ConvexHullGeometry mDOM; // Declare the DOM version.
};


// Defines a triangle mesh geometry
class TriangleMeshGeometryDef : public GeometryDef
{
public:
	// Declare the constructor.
	TriangleMeshGeometryDef()
	{
		GeometryDef::mType = GT_TRIANGLEMESH_GEOMETRY;
	}


	// Declare the virtual destructor.
	virtual ~TriangleMeshGeometryDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	TriangleMeshGeometryDef(const TriangleMeshGeometryDef &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual TriangleMeshGeometry * getTriangleMeshGeometry(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new TriangleMeshGeometryDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	TriangleMeshGeometryDef& operator=(const TriangleMeshGeometryDef& other)
	{
		if (this != &other )
		{
			GeometryDef::operator=(other);
			mScale = other.mScale;
			mTriangleMesh = other.mTriangleMesh;
			mDoubleSided = other.mDoubleSided;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		GeometryDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Geometry *dom = static_cast< Geometry *>(&mDOM); // Get the DOM base class.
			*dom = *(GeometryDef::getGeometry()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.scale = mScale; // Simple member variable assignment to the DOM reflection: scale
		mDOM.triangleMesh = mTriangleMesh.c_str(); // Assign the current string pointer.
		mDOM.doubleSided = mDoubleSided; // Simple member variable assignment to the DOM reflection: doubleSided
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	TriangleMeshGeometryDef(TriangleMeshGeometryDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	TriangleMeshGeometryDef& operator=(TriangleMeshGeometryDef&& other)
	{
		if (this != &other )
		{
			GeometryDef::operator=(std::move(other));
			mScale = other.mScale;
			mTriangleMesh = other.mTriangleMesh;
			mDoubleSided = other.mDoubleSided;
		}
		return *this;
	}

	MeshScale  	mScale;											// The scale of the triangle mesh
	std::string	mTriangleMesh;   								// The name of the triangle mesh asset
	bool 		mDoubleSided{ false };  								// Whether or not this triangle mesh should be treated as double sided for collision detection
private:
	TriangleMeshGeometry mDOM; // Declare the DOM version.
};


// Defines a heightfield geometry
class HeightFieldGeometryDef : public GeometryDef
{
public:
	// Declare the constructor.
	HeightFieldGeometryDef()
	{
		GeometryDef::mType = GT_HEIGHTFIELD_GEOMETRY;
	}


	// Declare the virtual destructor.
	virtual ~HeightFieldGeometryDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	HeightFieldGeometryDef(const HeightFieldGeometryDef &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual HeightFieldGeometry * getHeightFieldGeometry(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new HeightFieldGeometryDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	HeightFieldGeometryDef& operator=(const HeightFieldGeometryDef& other)
	{
		if (this != &other )
		{
			GeometryDef::operator=(other);
			mHeightField = other.mHeightField;
			mHeightScale = other.mHeightScale;
			mRowScale = other.mRowScale;
			mColumnScale = other.mColumnScale;
			mDoubleSided = other.mDoubleSided;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		GeometryDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Geometry *dom = static_cast< Geometry *>(&mDOM); // Get the DOM base class.
			*dom = *(GeometryDef::getGeometry()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.heightField = mHeightField.c_str(); // Assign the current string pointer.
		mDOM.heightScale = mHeightScale; // Simple member variable assignment to the DOM reflection: heightScale
		mDOM.rowScale = mRowScale; // Simple member variable assignment to the DOM reflection: rowScale
		mDOM.columnScale = mColumnScale; // Simple member variable assignment to the DOM reflection: columnScale
		mDOM.doubleSided = mDoubleSided; // Simple member variable assignment to the DOM reflection: doubleSided
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	HeightFieldGeometryDef(HeightFieldGeometryDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	HeightFieldGeometryDef& operator=(HeightFieldGeometryDef&& other)
	{
		if (this != &other )
		{
			GeometryDef::operator=(std::move(other));
			mHeightField = other.mHeightField;
			mHeightScale = other.mHeightScale;
			mRowScale = other.mRowScale;
			mColumnScale = other.mColumnScale;
			mDoubleSided = other.mDoubleSided;
		}
		return *this;
	}

	std::string	mHeightField;  									// The id of the heightfield data asset
	float  		mHeightScale{ 1 };									// The scaling factor for the height field in vertical direction (y direction in local space).
	float  		mRowScale{ 1 }; 									// The scaling factor for the height field in the row direction (x direction in local space).
	float  		mColumnScale{ 1 };									// The scaling factor for the height field in the column direction (z direction in local space).
	bool 		mDoubleSided{ false };  								// Whether or not this heighfield should be treated as double sided for collision detection
private:
	HeightFieldGeometry mDOM; // Declare the DOM version.
};


// Defines a plane equation geometry (position and orientation of the plane come from the geometry instance)
class PlaneGeometryDef : public GeometryDef
{
public:
	// Declare the constructor.
	PlaneGeometryDef()
	{
		GeometryDef::mType = GT_PLANE_GEOMETRY;
	}


	// Declare the virtual destructor.
	virtual ~PlaneGeometryDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	PlaneGeometryDef(const PlaneGeometryDef &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual PlaneGeometry * getPlaneGeometry(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new PlaneGeometryDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	PlaneGeometryDef& operator=(const PlaneGeometryDef& other)
	{
		if (this != &other )
		{
			GeometryDef::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		GeometryDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Geometry *dom = static_cast< Geometry *>(&mDOM); // Get the DOM base class.
			*dom = *(GeometryDef::getGeometry()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	PlaneGeometryDef(PlaneGeometryDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	PlaneGeometryDef& operator=(PlaneGeometryDef&& other)
	{
		if (this != &other )
		{
			GeometryDef::operator=(std::move(other));
		}
		return *this;
	}

private:
	PlaneGeometry  mDOM; // Declare the DOM version.
};


// Defines a single instance of a geometry
class GeometryInstanceDef: public CloneObject
{
public:

	// Declare the constructor.
	GeometryInstanceDef() { }


	// Declare the virtual destructor; cleanup any pointers or arrays of pointers
	virtual ~GeometryInstanceDef()
	{
		delete mGeometry; // Delete this object
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	GeometryInstanceDef(const GeometryInstanceDef &other)
	{
		*this = other;
	}


	virtual GeometryInstance * getGeometryInstance(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new GeometryInstanceDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	GeometryInstanceDef& operator=(const GeometryInstanceDef& other)
	{
		if (this != &other )
		{
			delete mGeometry; // delete any previous pointer.
			mGeometry = nullptr; // set the pointer to null.
			if ( other.mGeometry )
			{
				mGeometry = static_cast<GeometryDef *>(other.mGeometry->clone()); // perform the deep copy and assignment here
			}
			mMaterials = other.mMaterials;
			mLocalPose = other.mLocalPose;
			mCollisionFilterSettings = other.mCollisionFilterSettings;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		if ( mGeometry )
		{
			mGeometry->initDOM(); // Initialize any DOM components of this object.
			mDOM.geometry = mGeometry->getGeometry(); // assign the DOM reflection pointer.
		}
		// Initialize the const char * array from the array of std::strings vector mMaterials
		mMaterialsDef.reserve(mMaterials.size()); // Reserve room for string pointers.
		for (auto &i: mMaterials) // For each std::string
			mMaterialsDef.push_back( i.c_str() ); // Add the const char * for the string.
		mDOM.materialsCount = uint32_t(mMaterialsDef.size()); // Assign the number of strings
		mDOM.materials = mDOM.materialsCount ? &mMaterialsDef[0] : nullptr; // Assign the pointer array.
		mDOM.localPose = mLocalPose; // Simple member variable assignment to the DOM reflection: localPose
		mDOM.collisionFilterSettings = mCollisionFilterSettings.c_str(); // Assign the current string pointer.
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	GeometryInstanceDef(GeometryInstanceDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	GeometryInstanceDef& operator=(GeometryInstanceDef&& other)
	{
		if (this != &other )
		{
			mGeometry = other.mGeometry;
			other.mGeometry = nullptr; // Set 'other' pointer to null since we have moved it
			mMaterials = other.mMaterials;
			mLocalPose = other.mLocalPose;
			mCollisionFilterSettings = other.mCollisionFilterSettings;
		}
		return *this;
	}

	GeometryDef	*mGeometry{ nullptr };   						// The geometry associated with this instance
	StringVector mMaterials; 									// Id of physical material(s) associated with this geometry instance (usually one material; but for heightifields and triangle meshes can be more than one)
	Pose 		mLocalPose;   										// The local pose for this geometry instance
	std::string	mCollisionFilterSettings;  						// Describes collision filtering settings; what other types of objects this object will collide with
private:
	GeometryInstance mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
	ConstCharVector mMaterialsDef; // Scratch array for const char pointers.
};

typedef std::vector< GeometryInstanceDef *> GeometryInstanceVectorDef; // Forward declare the 'GeometryInstance' vector for the implementation object pointers
typedef std::vector< GeometryInstance *> GeometryInstanceVectorDOM; // Forward declare the 'GeometryInstance' vector for the implementation object pointers

// Defines the common properties for a rigid body
class RigidBodyDef : public NodeDef
{
public:
	// Declare the constructor.
	RigidBodyDef()
	{
		NodeDef::mType = NT_RIGID_BODY;
	}


	// Declare the virtual destructor; cleanup any pointers or arrays of pointers
	virtual ~RigidBodyDef()
	{
		for (auto &i:mGeometryInstances) delete i; // Delete all of the object pointers in this array
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	RigidBodyDef(const RigidBodyDef &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual RigidBody * getRigidBody(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new RigidBodyDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	RigidBodyDef& operator=(const RigidBodyDef& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(other);
			for (auto &i:mGeometryInstances) delete i; // Delete all of the object pointers in this array
			mGeometryInstances.clear(); // Clear the current array
			mGeometryInstances.reserve(other.mGeometryInstances.size()); // Reserve number of items for the new array
			for (auto &i:other.mGeometryInstances) mGeometryInstances.push_back( static_cast< GeometryInstanceDef *>(i->clone())); // Deep copy object pointers into the array
			mGlobalPose = other.mGlobalPose;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeDef::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mGeometryInstancesDOM.clear();
		mGeometryInstancesDOM.reserve( mGeometryInstances.size() );
		for (auto &i:mGeometryInstances)
		{
			i->initDOM();
			mGeometryInstancesDOM.push_back( i->getGeometryInstance() );
		}
		mDOM.geometryInstancesCount = uint32_t(mGeometryInstancesDOM.size()); // assign the number of items in the array.
		mDOM.geometryInstances = mDOM.geometryInstancesCount ? &mGeometryInstancesDOM[0] : nullptr; // Assign the pointer array
		mDOM.globalPose = mGlobalPose; // Simple member variable assignment to the DOM reflection: globalPose
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	RigidBodyDef(RigidBodyDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	RigidBodyDef& operator=(RigidBodyDef&& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(std::move(other));
			mGeometryInstances = other.mGeometryInstances;
			other.mGeometryInstances.clear(); // Clear the 'other' array now that we have moved it
			mGlobalPose = other.mGlobalPose;
		}
		return *this;
	}

	GeometryInstanceVectorDef mGeometryInstances;  				// The set of geometries to instance with this actor
	Pose 		mGlobalPose;											// The global pose for this actor
private:
	RigidBody  	mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
	GeometryInstanceVectorDOM mGeometryInstancesDOM; // Scratch array for const char pointers.
};


// Defines a static rigid body
class RigidStaticDef : public RigidBodyDef
{
public:
	// Declare the constructor.
	RigidStaticDef()
	{
		NodeDef::mType = NT_RIGID_STATIC;
	}


	// Declare the virtual destructor.
	virtual ~RigidStaticDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	RigidStaticDef(const RigidStaticDef &other)
	{
		*this = other;
	}


	virtual RigidBody * getRigidBody(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual RigidStatic * getRigidStatic(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual Node * getNode(void) // Declare virtual method to return the DOM version based on multiple inheritance
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new RigidStaticDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	RigidStaticDef& operator=(const RigidStaticDef& other)
	{
		if (this != &other )
		{
			RigidBodyDef::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		RigidBodyDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			RigidBody *dom = static_cast< RigidBody *>(&mDOM); // Get the DOM base class.
			*dom = *(RigidBodyDef::getRigidBody()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	RigidStaticDef(RigidStaticDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	RigidStaticDef& operator=(RigidStaticDef&& other)
	{
		if (this != &other )
		{
			RigidBodyDef::operator=(std::move(other));
		}
		return *this;
	}

private:
	RigidStatic	mDOM; // Declare the DOM version.
};


// Defines a dynamic rigid body
class RigidDynamicDef : public RigidBodyDef
{
public:
	// Declare the constructor.
	RigidDynamicDef()
	{
		NodeDef::mType = NT_RIGID_DYNAMIC;
	}


	// Declare the virtual destructor.
	virtual ~RigidDynamicDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	RigidDynamicDef(const RigidDynamicDef &other)
	{
		*this = other;
	}


	virtual RigidBody * getRigidBody(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual RigidDynamic * getRigidDynamic(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual Node * getNode(void) // Declare virtual method to return the DOM version based on multiple inheritance
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new RigidDynamicDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	RigidDynamicDef& operator=(const RigidDynamicDef& other)
	{
		if (this != &other )
		{
			RigidBodyDef::operator=(other);
			mDisableGravity = other.mDisableGravity;
			mCenterOfMassLocalPose = other.mCenterOfMassLocalPose;
			mMass = other.mMass;
			mMassSpaceInertiaTensor = other.mMassSpaceInertiaTensor;
			mLinearVelocity = other.mLinearVelocity;
			mAngularVelocity = other.mAngularVelocity;
			mLinearDamping = other.mLinearDamping;
			mAngularDamping = other.mAngularDamping;
			mMaxAngularVelocity = other.mMaxAngularVelocity;
			mKinematic = other.mKinematic;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		RigidBodyDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			RigidBody *dom = static_cast< RigidBody *>(&mDOM); // Get the DOM base class.
			*dom = *(RigidBodyDef::getRigidBody()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.disableGravity = mDisableGravity; // Simple member variable assignment to the DOM reflection: disableGravity
		mDOM.centerOfMassLocalPose = mCenterOfMassLocalPose; // Simple member variable assignment to the DOM reflection: centerOfMassLocalPose
		mDOM.mass = mMass; // Simple member variable assignment to the DOM reflection: mass
		mDOM.massSpaceInertiaTensor = mMassSpaceInertiaTensor; // Simple member variable assignment to the DOM reflection: massSpaceInertiaTensor
		mDOM.linearVelocity = mLinearVelocity; // Simple member variable assignment to the DOM reflection: linearVelocity
		mDOM.angularVelocity = mAngularVelocity; // Simple member variable assignment to the DOM reflection: angularVelocity
		mDOM.linearDamping = mLinearDamping; // Simple member variable assignment to the DOM reflection: linearDamping
		mDOM.angularDamping = mAngularDamping; // Simple member variable assignment to the DOM reflection: angularDamping
		mDOM.maxAngularVelocity = mMaxAngularVelocity; // Simple member variable assignment to the DOM reflection: maxAngularVelocity
		mDOM.kinematic = mKinematic; // Simple member variable assignment to the DOM reflection: kinematic
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	RigidDynamicDef(RigidDynamicDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	RigidDynamicDef& operator=(RigidDynamicDef&& other)
	{
		if (this != &other )
		{
			RigidBodyDef::operator=(std::move(other));
			mDisableGravity = other.mDisableGravity;
			mCenterOfMassLocalPose = other.mCenterOfMassLocalPose;
			mMass = other.mMass;
			mMassSpaceInertiaTensor = other.mMassSpaceInertiaTensor;
			mLinearVelocity = other.mLinearVelocity;
			mAngularVelocity = other.mAngularVelocity;
			mLinearDamping = other.mLinearDamping;
			mAngularDamping = other.mAngularDamping;
			mMaxAngularVelocity = other.mMaxAngularVelocity;
			mKinematic = other.mKinematic;
		}
		return *this;
	}

	bool 		mDisableGravity{ false }; 							// Disables scene gravity for this actor
	Pose 		mCenterOfMassLocalPose;   							// Center of mass and local pose
	float  		mMass{ 1 }; 										// Sets the mass of a dynamic actor.
	Vec3 		mMassSpaceInertiaTensor{ 1,1,1 }; 					// Sets the inertia tensor, using a parameter specified in mass space coordinates.
	Vec3 		mLinearVelocity{ 0,0,0 }; 							// Sets the linear velocity of the actor.
	Vec3 		mAngularVelocity{ 0,0,0 };  							// Sets the angular velocity of the actor.
	float  		mLinearDamping{ 0 };  								// Sets the linear damping coefficient.
	float  		mAngularDamping{ 0.05f };   						// Sets the angular damping coefficient.
	float  		mMaxAngularVelocity{ 7 };   						// set the maximum angular velocity permitted for this actor.
	bool 		mKinematic{ false };									// If true this is a dynamic object; but currently kinematically controlled
private:
	RigidDynamic mDOM; // Declare the DOM version.
};


// Defines the common properties for a joint
class JointDef : public NodeDef
{
public:
	// Declare the constructor.
	JointDef()
	{
		NodeDef::mType = NT_JOINT;
	}


	// Declare the virtual destructor.
	virtual ~JointDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	JointDef(const JointDef &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual Joint * getJoint(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new JointDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	JointDef& operator=(const JointDef& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(other);
			mBody0 = other.mBody0;
			mBody1 = other.mBody1;
			mLocalpose0 = other.mLocalpose0;
			mLocalpose1 = other.mLocalpose1;
			mCollisionEnabled = other.mCollisionEnabled;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeDef::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.body0 = mBody0.c_str(); // Assign the current string pointer.
		mDOM.body1 = mBody1.c_str(); // Assign the current string pointer.
		mDOM.localpose0 = mLocalpose0; // Simple member variable assignment to the DOM reflection: localpose0
		mDOM.localpose1 = mLocalpose1; // Simple member variable assignment to the DOM reflection: localpose1
		mDOM.collisionEnabled = mCollisionEnabled; // Simple member variable assignment to the DOM reflection: collisionEnabled
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	JointDef(JointDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	JointDef& operator=(JointDef&& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(std::move(other));
			mBody0 = other.mBody0;
			mBody1 = other.mBody1;
			mLocalpose0 = other.mLocalpose0;
			mLocalpose1 = other.mLocalpose1;
			mCollisionEnabled = other.mCollisionEnabled;
		}
		return *this;
	}

	std::string	mBody0;											// Id of first rigid body joint is constrained to; if empty string; then constaint to the world
	std::string	mBody1;											// Id of the second rigid body the joint is constrainted to
	Pose 		mLocalpose0;											// The parent relative pose; relative to body0
	Pose 		mLocalpose1;											// The parent relative pose; relative to body1
	bool 		mCollisionEnabled{ false };   						// 
private:
	Joint  		mDOM; // Declare the DOM version.
};


// Defines the properties specific to a fixed joint 
// Not all properties yet defined!
class FixedJointDef : public JointDef
{
public:
	// Declare the constructor.
	FixedJointDef()
	{
		JointDef::mType = NT_FIXED_JOINT;
	}


	// Declare the virtual destructor.
	virtual ~FixedJointDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	FixedJointDef(const FixedJointDef &other)
	{
		*this = other;
	}


	virtual Joint * getJoint(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual FixedJoint * getFixedJoint(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual Node * getNode(void) // Declare virtual method to return the DOM version based on multiple inheritance
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new FixedJointDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	FixedJointDef& operator=(const FixedJointDef& other)
	{
		if (this != &other )
		{
			JointDef::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		JointDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Joint *dom = static_cast< Joint *>(&mDOM); // Get the DOM base class.
			*dom = *(JointDef::getJoint()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	FixedJointDef(FixedJointDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	FixedJointDef& operator=(FixedJointDef&& other)
	{
		if (this != &other )
		{
			JointDef::operator=(std::move(other));
		}
		return *this;
	}

private:
	FixedJoint   mDOM; // Declare the DOM version.
};


// Defines the properties specific to a spherical joint 
// Not all properties yet defined!
class SphericalJointDef : public JointDef
{
public:
	// Declare the constructor.
	SphericalJointDef()
	{
		JointDef::mType = NT_SPHERICAL_JOINT;
	}


	// Declare the virtual destructor.
	virtual ~SphericalJointDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	SphericalJointDef(const SphericalJointDef &other)
	{
		*this = other;
	}


	virtual Joint * getJoint(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual SphericalJoint * getSphericalJoint(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual Node * getNode(void) // Declare virtual method to return the DOM version based on multiple inheritance
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new SphericalJointDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	SphericalJointDef& operator=(const SphericalJointDef& other)
	{
		if (this != &other )
		{
			JointDef::operator=(other);
			mLimitY = other.mLimitY;
			mLimitZ = other.mLimitZ;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		JointDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Joint *dom = static_cast< Joint *>(&mDOM); // Get the DOM base class.
			*dom = *(JointDef::getJoint()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.limitY = mLimitY; // Simple member variable assignment to the DOM reflection: limitY
		mDOM.limitZ = mLimitZ; // Simple member variable assignment to the DOM reflection: limitZ
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	SphericalJointDef(SphericalJointDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	SphericalJointDef& operator=(SphericalJointDef&& other)
	{
		if (this != &other )
		{
			JointDef::operator=(std::move(other));
			mLimitY = other.mLimitY;
			mLimitZ = other.mLimitZ;
		}
		return *this;
	}

	float  		mLimitY{ 0 };   									// The limit angle (in radians) for the y rotation axis
	float  		mLimitZ{ 0 };   									// The limit angle (in radians) for the z rotation axis
private:
	SphericalJoint   mDOM; // Declare the DOM version.
};


// Defines the properties specific to a revolute joint 
// Not all properties yet defined!
class HingeJointDef : public JointDef
{
public:
	// Declare the constructor.
	HingeJointDef()
	{
		JointDef::mType = NT_HINGE_JOINT;
	}


	// Declare the virtual destructor.
	virtual ~HingeJointDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	HingeJointDef(const HingeJointDef &other)
	{
		*this = other;
	}


	virtual Joint * getJoint(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual HingeJoint * getHingeJoint(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual Node * getNode(void) // Declare virtual method to return the DOM version based on multiple inheritance
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new HingeJointDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	HingeJointDef& operator=(const HingeJointDef& other)
	{
		if (this != &other )
		{
			JointDef::operator=(other);
			mLimtLow = other.mLimtLow;
			mLimitHigh = other.mLimitHigh;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		JointDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Joint *dom = static_cast< Joint *>(&mDOM); // Get the DOM base class.
			*dom = *(JointDef::getJoint()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.limtLow = mLimtLow; // Simple member variable assignment to the DOM reflection: limtLow
		mDOM.limitHigh = mLimitHigh; // Simple member variable assignment to the DOM reflection: limitHigh
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	HingeJointDef(HingeJointDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	HingeJointDef& operator=(HingeJointDef&& other)
	{
		if (this != &other )
		{
			JointDef::operator=(std::move(other));
			mLimtLow = other.mLimtLow;
			mLimitHigh = other.mLimitHigh;
		}
		return *this;
	}

	float  		mLimtLow{ 0 };										// The lower limit of the hinge joint in radians
	float  		mLimitHigh{ 0 };  									// The upper limit of the hinge joint in radians
private:
	HingeJoint   mDOM; // Declare the DOM version.
};


// Defines the properties specific to a prismatic joint 
// Not all properties yet defined!
class PrismaticJointDef : public JointDef
{
public:
	// Declare the constructor.
	PrismaticJointDef()
	{
		JointDef::mType = NT_PRISMATIC_JOINT;
	}


	// Declare the virtual destructor.
	virtual ~PrismaticJointDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	PrismaticJointDef(const PrismaticJointDef &other)
	{
		*this = other;
	}


	virtual Joint * getJoint(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual PrismaticJoint * getPrismaticJoint(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual Node * getNode(void) // Declare virtual method to return the DOM version based on multiple inheritance
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new PrismaticJointDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	PrismaticJointDef& operator=(const PrismaticJointDef& other)
	{
		if (this != &other )
		{
			JointDef::operator=(other);
			mLimitLow = other.mLimitLow;
			mLimitHigh = other.mLimitHigh;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		JointDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Joint *dom = static_cast< Joint *>(&mDOM); // Get the DOM base class.
			*dom = *(JointDef::getJoint()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.limitLow = mLimitLow; // Simple member variable assignment to the DOM reflection: limitLow
		mDOM.limitHigh = mLimitHigh; // Simple member variable assignment to the DOM reflection: limitHigh
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	PrismaticJointDef(PrismaticJointDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	PrismaticJointDef& operator=(PrismaticJointDef&& other)
	{
		if (this != &other )
		{
			JointDef::operator=(std::move(other));
			mLimitLow = other.mLimitLow;
			mLimitHigh = other.mLimitHigh;
		}
		return *this;
	}

	float  		mLimitLow{ 0 }; 									// The lower linear limit distance
	float  		mLimitHigh; 										// The upper linear limit distance
private:
	PrismaticJoint   mDOM; // Declare the DOM version.
};


// Defines the properties specific to a distance joint 
// Not all properties yet defined!
class DistanceJointDef : public JointDef
{
public:
	// Declare the constructor.
	DistanceJointDef()
	{
		JointDef::mType = NT_DISTANCE_JOINT;
	}


	// Declare the virtual destructor.
	virtual ~DistanceJointDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	DistanceJointDef(const DistanceJointDef &other)
	{
		*this = other;
	}


	virtual Joint * getJoint(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual DistanceJoint * getDistanceJoint(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual Node * getNode(void) // Declare virtual method to return the DOM version based on multiple inheritance
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new DistanceJointDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	DistanceJointDef& operator=(const DistanceJointDef& other)
	{
		if (this != &other )
		{
			JointDef::operator=(other);
			mDistanceLow = other.mDistanceLow;
			mDistanceHigh = other.mDistanceHigh;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		JointDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Joint *dom = static_cast< Joint *>(&mDOM); // Get the DOM base class.
			*dom = *(JointDef::getJoint()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.distanceLow = mDistanceLow; // Simple member variable assignment to the DOM reflection: distanceLow
		mDOM.distanceHigh = mDistanceHigh; // Simple member variable assignment to the DOM reflection: distanceHigh
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	DistanceJointDef(DistanceJointDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	DistanceJointDef& operator=(DistanceJointDef&& other)
	{
		if (this != &other )
		{
			JointDef::operator=(std::move(other));
			mDistanceLow = other.mDistanceLow;
			mDistanceHigh = other.mDistanceHigh;
		}
		return *this;
	}

	float  		mDistanceLow{ 0 };									// The minimum distance allowed between the two bodies
	float  		mDistanceHigh{ 0 }; 								// The maximum distance allowed between the two bodies
private:
	DistanceJoint  mDOM; // Declare the DOM version.
};


// Defines the properties specific to a ball and socket joint 
// Not all properties yet defined!
class BallAndSocketJointDef : public JointDef
{
public:
	// Declare the constructor.
	BallAndSocketJointDef()
	{
		JointDef::mType = NT_BALL_AND_SOCKET_JOINT;
	}


	// Declare the virtual destructor.
	virtual ~BallAndSocketJointDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	BallAndSocketJointDef(const BallAndSocketJointDef &other)
	{
		*this = other;
	}


	virtual Joint * getJoint(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual BallAndSocketJoint * getBallAndSocketJoint(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual Node * getNode(void) // Declare virtual method to return the DOM version based on multiple inheritance
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new BallAndSocketJointDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	BallAndSocketJointDef& operator=(const BallAndSocketJointDef& other)
	{
		if (this != &other )
		{
			JointDef::operator=(other);
			mLimitXLow = other.mLimitXLow;
			mLimitXHigh = other.mLimitXHigh;
			mLimitY = other.mLimitY;
			mLimitZ = other.mLimitZ;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		JointDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Joint *dom = static_cast< Joint *>(&mDOM); // Get the DOM base class.
			*dom = *(JointDef::getJoint()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.limitXLow = mLimitXLow; // Simple member variable assignment to the DOM reflection: limitXLow
		mDOM.limitXHigh = mLimitXHigh; // Simple member variable assignment to the DOM reflection: limitXHigh
		mDOM.limitY = mLimitY; // Simple member variable assignment to the DOM reflection: limitY
		mDOM.limitZ = mLimitZ; // Simple member variable assignment to the DOM reflection: limitZ
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	BallAndSocketJointDef(BallAndSocketJointDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	BallAndSocketJointDef& operator=(BallAndSocketJointDef&& other)
	{
		if (this != &other )
		{
			JointDef::operator=(std::move(other));
			mLimitXLow = other.mLimitXLow;
			mLimitXHigh = other.mLimitXHigh;
			mLimitY = other.mLimitY;
			mLimitZ = other.mLimitZ;
		}
		return *this;
	}

	float  		mLimitXLow{ 0 };  									// The lower angle limit, in radians, for the X rotation axis
	float  		mLimitXHigh{ 0 };   								// The upper angle limit, in radians, for the X rotation axis
	float  		mLimitY{ 0 };   									// The limit angle (in radians) for the y rotation axis
	float  		mLimitZ{ 0 };   									// The limit angle (in radians) for the z rotation axis
private:
	BallAndSocketJoint mDOM; // Declare the DOM version.
};


// Defines the properties specific to a six degree of freedom joint 
// Not all properties yet defined!
class D6JointDef : public JointDef
{
public:
	// Declare the constructor.
	D6JointDef()
	{
		JointDef::mType = NT_D6_JOINT;
	}


	// Declare the virtual destructor.
	virtual ~D6JointDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	D6JointDef(const D6JointDef &other)
	{
		*this = other;
	}


	virtual Joint * getJoint(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual D6Joint * getD6Joint(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual Node * getNode(void) // Declare virtual method to return the DOM version based on multiple inheritance
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new D6JointDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	D6JointDef& operator=(const D6JointDef& other)
	{
		if (this != &other )
		{
			JointDef::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		JointDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Joint *dom = static_cast< Joint *>(&mDOM); // Get the DOM base class.
			*dom = *(JointDef::getJoint()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	D6JointDef(D6JointDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	D6JointDef& operator=(D6JointDef&& other)
	{
		if (this != &other )
		{
			JointDef::operator=(std::move(other));
		}
		return *this;
	}

private:
	D6Joint		mDOM; // Declare the DOM version.
};


// Defines two bodies, by id, that should not collide with each other
class BodyPairFilterDef: public CloneObject
{
public:

	// Declare the constructor.
	BodyPairFilterDef() { }


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	BodyPairFilterDef(const BodyPairFilterDef &other)
	{
		*this = other;
	}


	virtual BodyPairFilter * getBodyPairFilter(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new BodyPairFilterDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	BodyPairFilterDef& operator=(const BodyPairFilterDef& other)
	{
		if (this != &other )
		{
			mBodyA = other.mBodyA;
			mBodyB  = other.mBodyB ;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		mDOM.bodyA = mBodyA.c_str(); // Assign the current string pointer.
		mDOM.bodyB  = mBodyB .c_str(); // Assign the current string pointer.
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	BodyPairFilterDef(BodyPairFilterDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	BodyPairFilterDef& operator=(BodyPairFilterDef&& other)
	{
		if (this != &other )
		{
			mBodyA = other.mBodyA;
			mBodyB  = other.mBodyB ;
		}
		return *this;
	}

	std::string	mBodyA;											// Id of first body
	std::string	mBodyB ; 										// Id of second body
private:
	BodyPairFilter   mDOM; // Declare the DOM version.
};

typedef std::vector< BodyPairFilterDef > BodyPairFilterVectorDef; // Forward declare the 'BodyPairFilter' vector
typedef std::vector< BodyPairFilter > BodyPairFilterVectorDOM; // Forward declare the 'BodyPairFilter' vector

// A collection of body pair filters
class BodyPairFiltersDef : public NodeDef
{
public:
	// Declare the constructor.
	BodyPairFiltersDef()
	{
		NodeDef::mType = NT_BODY_PAIR_FILTERS;
	}


	// Declare the virtual destructor.
	virtual ~BodyPairFiltersDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	BodyPairFiltersDef(const BodyPairFiltersDef &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual BodyPairFilters * getBodyPairFilters(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new BodyPairFiltersDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	BodyPairFiltersDef& operator=(const BodyPairFiltersDef& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(other);
			mBodyPairs = other.mBodyPairs;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeDef::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mBodyPairsDOM.clear();
		mBodyPairsDOM.reserve( mBodyPairs.size() );
		for (auto &i:mBodyPairs)
		{
			i.initDOM();
			mBodyPairsDOM.push_back( *(i.getBodyPairFilter()) );
		}
		mDOM.bodyPairsCount = uint32_t(mBodyPairsDOM.size()); // assign the number of items in the array.
		mDOM.bodyPairs = mDOM.bodyPairsCount ? &mBodyPairsDOM[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	BodyPairFiltersDef(BodyPairFiltersDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	BodyPairFiltersDef& operator=(BodyPairFiltersDef&& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(std::move(other));
			mBodyPairs = other.mBodyPairs;
		}
		return *this;
	}

	BodyPairFilterVectorDef mBodyPairs;							// Array of body pair filters
private:
	BodyPairFilters mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
	BodyPairFilterVectorDOM mBodyPairsDOM; // Scratch array for const char pointers.
};


class InstanceCollectionDef : public NodeDef
{
public:
	// Declare the constructor.
	InstanceCollectionDef()
	{
		NodeDef::mType = NT_INSTANCE_COLLECTION;
	}


	// Declare the virtual destructor.
	virtual ~InstanceCollectionDef()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	InstanceCollectionDef(const InstanceCollectionDef &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual InstanceCollection * getInstanceCollection(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new InstanceCollectionDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	InstanceCollectionDef& operator=(const InstanceCollectionDef& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(other);
			mCollection = other.mCollection;
			mPose = other.mPose;
			mScale = other.mScale;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeDef::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.collection = mCollection.c_str(); // Assign the current string pointer.
		mDOM.pose = mPose; // Simple member variable assignment to the DOM reflection: pose
		mDOM.scale = mScale; // Simple member variable assignment to the DOM reflection: scale
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	InstanceCollectionDef(InstanceCollectionDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	InstanceCollectionDef& operator=(InstanceCollectionDef&& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(std::move(other));
			mCollection = other.mCollection;
			mPose = other.mPose;
			mScale = other.mScale;
		}
		return *this;
	}

	std::string	mCollection; 									// Name of collection to instance
	Pose 		mPose;  												// Pose to instance collection at
	Vec3 		mScale;   											// Scale of instance
private:
	InstanceCollection mDOM; // Declare the DOM version.
};

typedef std::vector< NodeDef *> NodeVectorDef; // Forward declare the 'Node' vector for the implementation object pointers
typedef std::vector< Node *> NodeVectorDOM; // Forward declare the 'Node' vector for the implementation object pointers

// A collection of nodes
class CollectionDef : public NodeDef
{
public:
	// Declare the constructor.
	CollectionDef()
	{
		NodeDef::mType = NT_COLLECTION;
	}


	// Declare the virtual destructor; cleanup any pointers or arrays of pointers
	virtual ~CollectionDef()
	{
		for (auto &i:mNodes) delete i; // Delete all of the object pointers in this array
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	CollectionDef(const CollectionDef &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual Collection * getCollection(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new CollectionDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	CollectionDef& operator=(const CollectionDef& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(other);
			for (auto &i:mNodes) delete i; // Delete all of the object pointers in this array
			mNodes.clear(); // Clear the current array
			mNodes.reserve(other.mNodes.size()); // Reserve number of items for the new array
			for (auto &i:other.mNodes) mNodes.push_back( static_cast< NodeDef *>(i->clone())); // Deep copy object pointers into the array
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeDef::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mNodesDOM.clear();
		mNodesDOM.reserve( mNodes.size() );
		for (auto &i:mNodes)
		{
			i->initDOM();
			mNodesDOM.push_back( i->getNode() );
		}
		mDOM.nodesCount = uint32_t(mNodesDOM.size()); // assign the number of items in the array.
		mDOM.nodes = mDOM.nodesCount ? &mNodesDOM[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	CollectionDef(CollectionDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	CollectionDef& operator=(CollectionDef&& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(std::move(other));
			mNodes = other.mNodes;
			other.mNodes.clear(); // Clear the 'other' array now that we have moved it
		}
		return *this;
	}

	NodeVectorDef  mNodes;   									// Array of nodes in this collection
private:
	Collection   mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
	NodeVectorDOM  mNodesDOM; // Scratch array for const char pointers.
};


// A special type of 'collection' which is instantiated on startup
class SceneDef : public NodeDef
{
public:
	// Declare the constructor.
	SceneDef()
	{
		NodeDef::mType = NT_SCENE;
	}


	// Declare the virtual destructor; cleanup any pointers or arrays of pointers
	virtual ~SceneDef()
	{
		for (auto &i:mNodes) delete i; // Delete all of the object pointers in this array
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	SceneDef(const SceneDef &other)
	{
		*this = other;
	}


	virtual Node * getNode(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	virtual Scene * getScene(void) // Declare virtual method to return the DOM version
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new SceneDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	SceneDef& operator=(const SceneDef& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(other);
			mGravity = other.mGravity;
			for (auto &i:mNodes) delete i; // Delete all of the object pointers in this array
			mNodes.clear(); // Clear the current array
			mNodes.reserve(other.mNodes.size()); // Reserve number of items for the new array
			for (auto &i:other.mNodes) mNodes.push_back( static_cast< NodeDef *>(i->clone())); // Deep copy object pointers into the array
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		NodeDef::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Node *dom = static_cast< Node *>(&mDOM); // Get the DOM base class.
			*dom = *(NodeDef::getNode()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.gravity = mGravity; // Simple member variable assignment to the DOM reflection: gravity
		mNodesDOM.clear();
		mNodesDOM.reserve( mNodes.size() );
		for (auto &i:mNodes)
		{
			i->initDOM();
			mNodesDOM.push_back( i->getNode() );
		}
		mDOM.nodesCount = uint32_t(mNodesDOM.size()); // assign the number of items in the array.
		mDOM.nodes = mDOM.nodesCount ? &mNodesDOM[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	SceneDef(SceneDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	SceneDef& operator=(SceneDef&& other)
	{
		if (this != &other )
		{
			NodeDef::operator=(std::move(other));
			mGravity = other.mGravity;
			mNodes = other.mNodes;
			other.mNodes.clear(); // Clear the 'other' array now that we have moved it
		}
		return *this;
	}

	Vec3 		mGravity{ 0.0f,-9.8f,0.0f };							// Gravity
	NodeVectorDef  mNodes;   									// Array of nodes in this collection
private:
	Scene  		mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
	NodeVectorDOM  mNodesDOM; // Scratch array for const char pointers.
};

typedef std::vector< CollectionDef *> CollectionVectorDef; // Forward declare the 'Collection' vector for the implementation object pointers
typedef std::vector< Collection *> CollectionVectorDOM; // Forward declare the 'Collection' vector for the implementation object pointers
typedef std::vector< SceneDef *> SceneVectorDef; // Forward declare the 'Scene' vector for the implementation object pointers
typedef std::vector< Scene *> SceneVectorDOM; // Forward declare the 'Scene' vector for the implementation object pointers

// The root node container
class PhysicsDOMDef: public CloneObject
{
public:

	// Declare the constructor.
	PhysicsDOMDef() { }


	// Declare the virtual destructor; cleanup any pointers or arrays of pointers
	virtual ~PhysicsDOMDef()
	{
		for (auto &i:mCollections) delete i; // Delete all of the object pointers in this array
		for (auto &i:mScenes) delete i; // Delete all of the object pointers in this array
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	PhysicsDOMDef(const PhysicsDOMDef &other)
	{
		*this = other;
	}


	virtual PhysicsDOM * getPhysicsDOM(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new PhysicsDOMDef(*this);
	}

	// Declare and implement the deep copy assignment operator
	PhysicsDOMDef& operator=(const PhysicsDOMDef& other)
	{
		if (this != &other )
		{
			for (auto &i:mCollections) delete i; // Delete all of the object pointers in this array
			mCollections.clear(); // Clear the current array
			mCollections.reserve(other.mCollections.size()); // Reserve number of items for the new array
			for (auto &i:other.mCollections) mCollections.push_back( static_cast< CollectionDef *>(i->clone())); // Deep copy object pointers into the array
			for (auto &i:mScenes) delete i; // Delete all of the object pointers in this array
			mScenes.clear(); // Clear the current array
			mScenes.reserve(other.mScenes.size()); // Reserve number of items for the new array
			for (auto &i:other.mScenes) mScenes.push_back( static_cast< SceneDef *>(i->clone())); // Deep copy object pointers into the array
		}
		return *this;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		mCollectionsDOM.clear();
		mCollectionsDOM.reserve( mCollections.size() );
		for (auto &i:mCollections)
		{
			i->initDOM();
			mCollectionsDOM.push_back( i->getCollection() );
		}
		mDOM.collectionsCount = uint32_t(mCollectionsDOM.size()); // assign the number of items in the array.
		mDOM.collections = mDOM.collectionsCount ? &mCollectionsDOM[0] : nullptr; // Assign the pointer array
		mScenesDOM.clear();
		mScenesDOM.reserve( mScenes.size() );
		for (auto &i:mScenes)
		{
			i->initDOM();
			mScenesDOM.push_back( i->getScene() );
		}
		mDOM.scenesCount = uint32_t(mScenesDOM.size()); // assign the number of items in the array.
		mDOM.scenes = mDOM.scenesCount ? &mScenesDOM[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	PhysicsDOMDef(PhysicsDOMDef &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	PhysicsDOMDef& operator=(PhysicsDOMDef&& other)
	{
		if (this != &other )
		{
			mCollections = other.mCollections;
			other.mCollections.clear(); // Clear the 'other' array now that we have moved it
			mScenes = other.mScenes;
			other.mScenes.clear(); // Clear the 'other' array now that we have moved it
		}
		return *this;
	}

	CollectionVectorDef mCollections;  							// The array of top level collections
	SceneVectorDef   mScenes;  									// The array of top level scenes; a scene is instantiated into the physics simulation
private:
	PhysicsDOM   mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
	CollectionVectorDOM mCollectionsDOM; // Scratch array for const char pointers.
	SceneVectorDOM   mScenesDOM; // Scratch array for const char pointers.
};



} // End of PHYSICS_DOM namespace

#endif // End of Scene
